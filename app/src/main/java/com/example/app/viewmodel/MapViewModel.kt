package com.example.app.viewmodel

import android.util.Log
import androidx.compose.runtime.State
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.app.models.*
import com.example.app.network.RetrofitClient
import com.example.app.network.RetrofitInstance
import com.example.app.repository.RutasRepository
import kotlinx.coroutines.launch
import org.osmdroid.util.GeoPoint
import kotlin.math.roundToInt

class MapViewModel(
    private val rutasRepository: RutasRepository
) : ViewModel() {

    private val _route = mutableStateOf<DirectionsResponse?>(null)
    val route: State<DirectionsResponse?> = _route

    private var currentMode = "foot-walking" // foot-walking, cycling-regular, etc.
    private var currentMLType: String? = null
    private var currentToken: String? = null

    private val _rutaIdActiva = mutableStateOf<Int?>(null)
    val rutaIdActiva: State<Int?> = _rutaIdActiva

    private val _mostrarOpcionesFinalizar = mutableStateOf(false)
    val mostrarOpcionesFinalizar: State<Boolean> = _mostrarOpcionesFinalizar

    // üî• NUEVAS VARIABLES para guardar datos de la ruta actual
    private var rutaActualUbicacionId: Int? = null
    private var rutaActualDistancia: Double? = null
    private var rutaActualDuracion: Double? = null

    private val _puntosGPSReales = mutableListOf<PuntoGPS>()

    private val _mostrarAlertaDesobediencia = mutableStateOf(false)
    val mostrarAlertaDesobediencia: State<Boolean> = _mostrarAlertaDesobediencia

    private val _mensajeAlertaDesobediencia = mutableStateOf<String?>(null)
    val mensajeAlertaDesobediencia: State<String?> = _mensajeAlertaDesobediencia

    fun agregarPuntoGPSReal(lat: Double, lng: Double) {
        val punto = PuntoGPS(
            lat = lat,
            lng = lng,
            timestamp = System.currentTimeMillis()
        )
        _puntosGPSReales.add(punto)
        Log.d("MapViewModel", "üìç Punto GPS agregado: $punto")
    }

    fun setMode(mode: String) {
        currentMode = mode
    }

    fun setToken(token: String) {
        currentToken = token
    }

    // Funci√≥n principal con ML y autenticaci√≥n
    fun fetchRouteWithML(
        start: Pair<Double, Double>,
        end: Pair<Double, Double>,
        token: String,
        ubicacionId: Int,
        transporteTexto: String? = null
    ) {
        currentToken = token
        rutaActualUbicacionId = ubicacionId // üî• GUARDAR para el feedback

        viewModelScope.launch {
            try {
                // PASO 1: Obtener recomendaci√≥n ML
                Log.d("MapViewModel", "Consultando ML con token...")

                val recomendacion = RetrofitClient.mlService.getRecomendacionTipoRuta(
                    "Bearer $token",
                    TipoRutaRequest(ubicacionId)
                )

                currentMLType = recomendacion.tipo_ruta
                Log.d(
                    "MapViewModel",
                    "ML recomienda: ${recomendacion.tipo_ruta} para usuario ${recomendacion.usuario_id}"
                )

                // PASO 2: Configurar OpenRouteService seg√∫n ML
                val (preference, avoidOptions) = recomendacion.tipo_ruta.toORSConfig()

                val request = DirectionsRequest(
                    coordinates = listOf(
                        listOf(start.second, start.first),
                        listOf(end.second, end.first)
                    ),
                    preference = preference,
                    options = avoidOptions
                )

                Log.d("MapViewModel", "Enviando request ORS: $request")
                Log.d(
                    "MapViewModel",
                    "üî• USANDO TIPO ML: ${recomendacion.tipo_ruta} -> ORS preference: $preference"
                )

                // PASO 3: Obtener ruta de OpenRouteService
                val response = RetrofitInstance.api.getRoute(currentMode, request)
                val responseWithProfile = response.copy(profile = currentMode)

                // üî• GUARDAR datos de la ruta para el feedback
                response.routes.firstOrNull()?.summary?.let { summary ->
                    rutaActualDistancia = summary.distance.toDouble()
                    rutaActualDuracion = summary.duration
                }

                Log.d(
                    "MapViewModel",
                    "Ruta obtenida: distancia=${response.routes.firstOrNull()?.summary?.distance}m"
                )

                _route.value = responseWithProfile

                // PASO 4: Guardar ruta CON el tipo usado
                if (transporteTexto != null) {
                    guardarRutaEnBackend(
                        responseWithProfile,
                        token,
                        ubicacionId,
                        transporteTexto,
                        recomendacion.tipo_ruta
                    )
                }

            } catch (e: Exception) {
                Log.e("MapViewModel", "Error fetching route with ML", e)
                _route.value = null
            }
        }
    }

    private suspend fun guardarRutaEnBackend(
        response: DirectionsResponse,
        token: String,
        ubicacionId: Int,
        transporteTexto: String,
        tipoRutaUsado: String
    ) {
        try {
            val rutaJson = response.toRutaUsuarioJson(
                ubicacionId = ubicacionId,
                transporteTexto = transporteTexto,
                tipoRutaUsado = tipoRutaUsado
            )

            Log.d("MapViewModel", "üìÖ Fecha de inicio generada en Android: ${rutaJson.fecha_inicio}")

            Log.d("MapViewModel", "Guardando ruta con tipo ML: $tipoRutaUsado")

            val result = rutasRepository.guardarRuta(token, rutaJson)
            result.onSuccess { rutaGuardada ->
                Log.d("MapViewModel", "‚úÖ Ruta guardada correctamente con tipo: $tipoRutaUsado")
                Log.d("MapViewModel", "Ruta completa: $rutaGuardada")
                _rutaIdActiva.value = rutaGuardada.id
                _mostrarOpcionesFinalizar.value = true
            }.onFailure { error ->
                Log.e("MapViewModel", "‚ùå Error al guardar ruta: ${error.message}")
            }
        } catch (e: Exception) {
            Log.e("MapViewModel", "Excepci√≥n al guardar ruta", e)
        }
    }

    fun clearRoute() {
        _route.value = null
        currentMLType = null
        rutaActualUbicacionId = null
        rutaActualDistancia = null
        rutaActualDuracion = null
        _puntosGPSReales.clear()
    }

    // En MapViewModel, reemplaza tu funci√≥n calcularSimilitudRuta() con esta versi√≥n mejorada
    // Versi√≥n mejorada de calcularSimilitudRuta con logging m√°s robusto
    private fun calcularSimilitudRuta(): Pair<Boolean, Double> {
        Log.d("MapViewModel", "üöÄ INICIANDO calcularSimilitudRuta()...")

        val rutaRecomendada = _route.value?.routes?.firstOrNull()?.geometry
        val puntosReales = _puntosGPSReales.toList()

        Log.d("MapViewModel", "üìä Datos iniciales:")
        Log.d("MapViewModel", "- Ruta recomendada existe: ${rutaRecomendada != null}")
        Log.d("MapViewModel", "- Puntos GPS reales: ${puntosReales.size}")

        if (rutaRecomendada == null || puntosReales.isEmpty()) {
            Log.w("MapViewModel", "‚ùå No hay datos suficientes para calcular similitud")
            return Pair(false, 0.0)
        }

        // Decodificar polyline de la ruta recomendada
        val puntosRecomendados = try {
            Log.d("MapViewModel", "üîÑ Decodificando polyline...")
            val puntos = rutaRecomendada.decodePolyline()
            Log.d("MapViewModel", "‚úÖ Polyline decodificado: ${puntos.size} puntos")
            puntos
        } catch (e: Exception) {
            Log.e("MapViewModel", "‚ùå Error decodificando polyline: ${e.message}", e)
            return Pair(false, 0.0)
        }

        if (puntosRecomendados.isEmpty()) {
            Log.w("MapViewModel", "‚ùå No se pudo decodificar polyline recomendado")
            return Pair(false, 0.0)
        }

        // ALGORITMO MEJORADO: Detectar incorporaci√≥n a la ruta
        val tolerancia = 80.0 // 80 metros (m√°s realista para navegaci√≥n urbana)
        var puntosEnRuta = 0
        var mejorSecuenciaConsecutiva = 0
        var secuenciaActual = 0
        var ultimosNPuntosEnRuta = 0

        // Analizar cada punto GPS real
        val distanciasDetalladas = mutableListOf<Double>()

        Log.d("MapViewModel", "üîÑ Analizando cada punto GPS...")

        for (i in puntosReales.indices) {
            val puntoReal = puntosReales[i]
            val puntoGeoReal = GeoPoint(puntoReal.lat, puntoReal.lng)

            // Buscar el punto recomendado m√°s cercano
            val distanciaMinima = try {
                puntosRecomendados.minOfOrNull { puntoRec ->
                    puntoGeoReal.distanceToAsDouble(puntoRec)
                } ?: Double.MAX_VALUE
            } catch (e: Exception) {
                Log.e("MapViewModel", "Error calculando distancia en punto $i: ${e.message}")
                Double.MAX_VALUE
            }

            distanciasDetalladas.add(distanciaMinima)

            if (distanciaMinima <= tolerancia) {
                puntosEnRuta++
                secuenciaActual++
                mejorSecuenciaConsecutiva = maxOf(mejorSecuenciaConsecutiva, secuenciaActual)

                // Contar √∫ltimos 5 puntos (para detectar si termina en la ruta)
                if (i >= puntosReales.size - 5) {
                    ultimosNPuntosEnRuta++
                }
            } else {
                secuenciaActual = 0
            }

            // Log cada 10 puntos para no saturar
            if (i % 10 == 0 || i == puntosReales.size - 1) {
                Log.d("MapViewModel", "üìç Punto $i: distancia=${distanciaMinima.roundToInt()}m, enRuta=${distanciaMinima <= tolerancia}")
            }
        }

        Log.d("MapViewModel", "üìä An√°lisis de puntos completado:")
        Log.d("MapViewModel", "- Puntos en ruta: $puntosEnRuta/${puntosReales.size}")
        Log.d("MapViewModel", "- Mejor secuencia consecutiva: $mejorSecuenciaConsecutiva")

        // Analizar inicio y fin de la ruta
        val inicioEnRuta = if (puntosReales.isNotEmpty()) {
            val puntoInicial = GeoPoint(puntosReales[0].lat, puntosReales[0].lng)
            val distanciaInicio = try {
                puntosRecomendados.minOfOrNull { puntoRec ->
                    puntoInicial.distanceToAsDouble(puntoRec)
                } ?: Double.MAX_VALUE
            } catch (e: Exception) {
                Log.e("MapViewModel", "Error calculando distancia inicio: ${e.message}")
                Double.MAX_VALUE
            }
            Log.d("MapViewModel", "üìç Distancia inicio: ${distanciaInicio.roundToInt()}m")
            distanciaInicio <= tolerancia * 1.5
        } else false

        val finEnRuta = if (puntosReales.isNotEmpty()) {
            val puntoFinal = GeoPoint(puntosReales.last().lat, puntosReales.last().lng)
            val distanciaFin = try {
                puntosRecomendados.minOfOrNull { puntoRec ->
                    puntoFinal.distanceToAsDouble(puntoRec)
                } ?: Double.MAX_VALUE
            } catch (e: Exception) {
                Log.e("MapViewModel", "Error calculando distancia fin: ${e.message}")
                Double.MAX_VALUE
            }
            Log.d("MapViewModel", "üìç Distancia fin: ${distanciaFin.roundToInt()}m")
            distanciaFin <= tolerancia * 1.5
        } else false

        // Calcular m√©tricas
        val similitudTotal = (puntosEnRuta.toDouble() / puntosReales.size) * 100
        val porcentajeSecuenciaConsecutiva = (mejorSecuenciaConsecutiva.toDouble() / puntosReales.size) * 100
        val porcentajeUltimoTramo = (ultimosNPuntosEnRuta.toDouble() / minOf(5, puntosReales.size)) * 100

        // LOGGING DETALLADO FORZADO (con println para asegurar que aparezca)
        println("üî• MAPVIEWMODEL - AN√ÅLISIS DETALLADO:")
        println("üî• Total puntos GPS: ${puntosReales.size}")
        println("üî• Puntos recomendados: ${puntosRecomendados.size}")
        println("üî• Puntos en ruta: $puntosEnRuta/${puntosReales.size} (${similitudTotal.roundToInt()}%)")
        println("üî• Mejor secuencia consecutiva: $mejorSecuenciaConsecutiva (${porcentajeSecuenciaConsecutiva.roundToInt()}%)")
        println("üî• √öltimos puntos en ruta: $ultimosNPuntosEnRuta/5 (${porcentajeUltimoTramo.roundToInt()}%)")
        println("üî• Inicio en ruta: $inicioEnRuta")
        println("üî• Fin en ruta: $finEnRuta")
        println("üî• Tolerancia usada: ${tolerancia}m")

        Log.d("MapViewModel", "=== AN√ÅLISIS DE RUTA DETALLADO ===")
        Log.d("MapViewModel", "Puntos GPS reales: ${puntosReales.size}")
        Log.d("MapViewModel", "Puntos recomendados: ${puntosRecomendados.size}")
        Log.d("MapViewModel", "Puntos en ruta: $puntosEnRuta/${puntosReales.size} (${similitudTotal.roundToInt()}%)")
        Log.d("MapViewModel", "Mejor secuencia consecutiva: $mejorSecuenciaConsecutiva (${porcentajeSecuenciaConsecutiva.roundToInt()}%)")
        Log.d("MapViewModel", "√öltimos puntos en ruta: $ultimosNPuntosEnRuta/5 (${porcentajeUltimoTramo.roundToInt()}%)")
        Log.d("MapViewModel", "Inicio en ruta: $inicioEnRuta")
        Log.d("MapViewModel", "Fin en ruta: $finEnRuta")
        Log.d("MapViewModel", "Tolerancia usada: ${tolerancia}m")

        // VALIDACI√ìN MANUAL con println
        println("üî• VALIDACI√ìN MANUAL:")
        println("üî• Total puntos GPS: ${puntosReales.size}")
        println("üî• Puntos dentro de 80m de la ruta: $puntosEnRuta")
        println("üî• C√°lculo manual: ${puntosEnRuta}/${puntosReales.size} = ${(puntosEnRuta.toDouble()/puntosReales.size)*100}%")

        Log.d("MapViewModel", "VALIDACI√ìN MANUAL:")
        Log.d("MapViewModel", "Total puntos GPS: ${puntosReales.size}")
        Log.d("MapViewModel", "Puntos dentro de 80m de la ruta: $puntosEnRuta")
        Log.d("MapViewModel", "C√°lculo manual: ${puntosEnRuta}/${puntosReales.size} = ${(puntosEnRuta.toDouble()/puntosReales.size)*100}%")

        // CRITERIO MEJORADO PARA DETECTAR SI SIGUI√ì LA RUTA:
        val siguioRuta = when {
            // Caso 1: Sigui√≥ la ruta desde el inicio (ruta perfecta)
            similitudTotal >= 70.0 && inicioEnRuta -> {
                Log.d("MapViewModel", "‚úÖ Caso 1: Ruta seguida desde el inicio")
                println("üî• Caso 1: Ruta seguida desde el inicio")
                true
            }

            // Caso 2: Se incorpor√≥ tarde pero sigui√≥ bien el resto (tu caso)
            similitudTotal >= 50.0 && porcentajeSecuenciaConsecutiva >= 40.0 && finEnRuta -> {
                Log.d("MapViewModel", "‚úÖ Caso 2: Incorporaci√≥n tard√≠a pero sigui√≥ la ruta")
                println("üî• Caso 2: Incorporaci√≥n tard√≠a pero sigui√≥ la ruta")
                true
            }

            // Caso 3: Termin√≥ bien en la ruta (√∫ltimos puntos en ruta)
            similitudTotal >= 40.0 && porcentajeUltimoTramo >= 60.0 -> {
                Log.d("MapViewModel", "‚úÖ Caso 3: Termin√≥ siguiendo la ruta correctamente")
                println("üî• Caso 3: Termin√≥ siguiendo la ruta correctamente")
                true
            }

            // Caso 4: Secuencia larga consecutiva (sigui√≥ un tramo largo)
            porcentajeSecuenciaConsecutiva >= 60.0 -> {
                Log.d("MapViewModel", "‚úÖ Caso 4: Sigui√≥ un tramo largo de la ruta")
                println("üî• Caso 4: Sigui√≥ un tramo largo de la ruta")
                true
            }

            else -> {
                Log.d("MapViewModel", "‚ùå No cumple criterios para 'sigui√≥ la ruta'")
                println("üî• No cumple criterios para 'sigui√≥ la ruta'")
                false
            }
        }

        // Log de las primeras distancias para debug
        if (distanciasDetalladas.size >= 5) {
            val primeras5 = distanciasDetalladas.take(5).map { "${it.roundToInt()}m" }
            Log.d("MapViewModel", "Primeras 5 distancias: $primeras5")
            println("üî• Primeras 5 distancias: $primeras5")
        }

        println("üî• RESULTADO FINAL: siguioRuta=$siguioRuta, similitud=${similitudTotal.roundToInt()}%")
        Log.d("MapViewModel", "üèÅ RESULTADO FINAL: siguioRuta=$siguioRuta, similitud=${similitudTotal.roundToInt()}%")

        return Pair(siguioRuta, similitudTotal)
    }

    // Tambi√©n actualiza la funci√≥n finalizarRutaBackend para usar el Pair
    fun finalizarRutaBackend(rutaId: Int) {
        viewModelScope.launch {
            try {
                val fechaFin = System.currentTimeMillis().toLocalISOString()
                val (siguioRuta, porcentajeSimilitud) = calcularSimilitudRuta()

                Log.d("MapViewModel", "üìä RESULTADO FINAL CALCULADO:")
                Log.d("MapViewModel", "- sigui√≥ ruta: $siguioRuta")
                Log.d("MapViewModel", "- porcentaje similitud: ${porcentajeSimilitud.roundToInt()}%")

                Log.d("MapViewModel", "üìÖ Fecha de fin generada en Android (finalizar): $fechaFin")
                Log.d("MapViewModel", "üì§ Enviando rutaId: $rutaId con ${_puntosGPSReales.size} puntos GPS")
                Log.d("MapViewModel", "Usuario sigui√≥ ruta: $siguioRuta (${porcentajeSimilitud.roundToInt()}% similitud)")

                Log.d("MapViewModel", "ANTES DE ENVIAR AL BACKEND:")
                Log.d("MapViewModel", "- siguioRuta: $siguioRuta")
                Log.d("MapViewModel", "- similitud: $porcentajeSimilitud")

                // üî• ENVIAR puntos GPS reales al backend
                val result = rutasRepository.finalizarRuta(
                    rutaId = rutaId,
                    fechaFin = fechaFin,
                    puntosGPS = _puntosGPSReales.toList(),
                    siguioRutaRecomendada = siguioRuta,
                    porcentajeSimilitud = porcentajeSimilitud
                )

                result.onSuccess { response ->
                    Log.d("MapViewModel", "‚úÖ Ruta finalizada: ${response.success}")

                    // üî• VERIFICAR si hay alerta de desobediencia
                    if (response.alerta_desobediencia && response.mensaje_alerta != null) {
                        Log.d("MapViewModel", "üö® ALERTA DESOBEDIENCIA: ${response.mensaje_alerta}")
                        _mostrarAlertaDesobediencia.value = true
                        _mensajeAlertaDesobediencia.value = response.mensaje_alerta
                    }

                    _mostrarOpcionesFinalizar.value = false
                    _route.value = null
                    _puntosGPSReales.clear()

                }.onFailure { error ->
                    Log.e("MapViewModel", "‚ùå Error finalizando ruta: ${error.message}")
                }

            } catch (e: Exception) {
                Log.e("MapViewModel", "Error finalizando ruta", e)
            }
        }
    }

    // üî• FUNCI√ìN CANCELAR - ahora con fecha_fin
    fun cancelarRutaBackend(rutaId: Int) {
        viewModelScope.launch {
            try {
                val fechaFin = System.currentTimeMillis().toLocalISOString()
                Log.d("MapViewModel", "üìÖ Fecha de fin generada en Android (cancelar): $fechaFin")

                rutasRepository.cancelarRuta(rutaId, fechaFin)  // Sin puntos GPS
                Log.d("MapViewModel", "‚úÖ Ruta cancelada en backend")

                _mostrarOpcionesFinalizar.value = false
                _route.value = null
                _puntosGPSReales.clear()  // Limpiar puntos GPS

            } catch (e: Exception) {
                Log.e("MapViewModel", "Error cancelando ruta", e)
            }
        }
    }

    // üî• FUNCI√ìN para cerrar alerta de desobediencia
    fun cerrarAlertaDesobediencia() {
        _mostrarAlertaDesobediencia.value = false
        _mensajeAlertaDesobediencia.value = null
    }

    // üî• NUEVA FUNCI√ìN para enviar feedback al UCB
    private suspend fun enviarFeedbackUCB(completada: Boolean) {
        try {
            val token = currentToken
            val tipoUsado = currentMLType
            val ubicacionId = rutaActualUbicacionId
            val distancia = rutaActualDistancia
            val duracion = rutaActualDuracion

            if (token == null || tipoUsado == null || ubicacionId == null) {
                Log.w("MapViewModel", "‚ùå Faltan datos para enviar feedback UCB")
                return
            }

            val feedbackRequest = FeedbackRequest(
                tipo_usado = tipoUsado,
                completada = completada,
                ubicacion_id = ubicacionId,
                distancia = distancia,
                duracion = duracion
            )

            Log.d("MapViewModel", "üì§ Enviando feedback UCB: $feedbackRequest")

            val response = RetrofitClient.mlService.enviarFeedback(
                "Bearer $token",
                feedbackRequest
            )

            Log.d("MapViewModel", "‚úÖ Feedback UCB enviado: ${response.mensaje}")

        } catch (e: Exception) {
            Log.e("MapViewModel", "‚ùå Error enviando feedback UCB: ${e.message}", e)
        }
    }

    fun ocultarOpcionesFinalizar() {
        _mostrarOpcionesFinalizar.value = false
        _rutaIdActiva.value = null
    }
}